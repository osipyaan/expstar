<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STARLING Example Pipeline</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8fafc;
            color: #1e293b;
        }
        /* Sticky top nav bar */
        nav {
            background-color: #1a73e8;
            padding: 10px 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            text-align: left;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 20px;
            font-weight: bold;
        }
        nav a:hover {
            text-decoration: underline;
        }
        header {
            background-color: #0f172a;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
        }
        main {
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        section {
            background: white;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #0f172a;
        }
        footer {
            text-align: center;
            background-color: #0f172a;
            color: #94a3b8;
            padding: 1rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<!-- Sticky Navigation Bar -->
<nav>
    <a href="https://osipyaan.github.io/expstar/">Home</a>
    <a href="https://osipyaan.github.io/expstar/pipeline" target="_blank">Example Pipeline</a>
    <a href="INSERT_CODE_LINK_HERE" target="_blank">Code</a>
    <a href="INSERT_CAMPBELL_LAB_LINK_HERE" target="_blank">Campbell Lab</a>
</nav>

<!-- Page Header -->
<header>
    <h1>STARLING: Making Spatial Biology Clear</h1>
    <img src="logo.png" alt="Logo" width="100" height="100" />
    <p>Understanding complex cell data — without the headaches.</p>
</header>
<body>

<div class="content">

<h1>STARLING Tutorial</h1>

<p>
    In this tutorial, we will use <strong>Google Colab</strong> to run STARLING — a probabilistic machine learning model for clustering spatial proteomics data.
    Google Colab is chosen so that you can run the example without worrying about local environment setup.
</p>

<p>
    Code for this tutorial can be accessed here: <a href="INSERT_CODE_LINK_HERE">[Code Link]</a><br>
    Credit to <strong>Campbell Lab</strong> for developing the STARLING library and providing the sample code:
    <a href="INSERT_CAMPBELL_LAB_LINK_HERE">[Campbell Lab Link]</a>
</p>

<hr>

<h2><a href="https://osipyaan.github.io/expstar/pipeline" target="_blank">Example Pipeline</a></h2>
<p>
    Click the heading above to see a full example pipeline for running STARLING, from installation to visualization.
    This external page provides a step-by-step breakdown of the data preprocessing, clustering, and plotting process.
</p>

<hr>

<h2>Step 1: Imports</h2>

<p>
    First, we will install the required Python packages. These include core analysis libraries like
    <code>scanpy</code>, <code>anndata</code>, and <code>numpy</code>, as well as visualization tools like
    <code>matplotlib</code> and <code>seaborn</code>. We also install STARLING itself and supporting tools like
    <code>phenograph</code> and <code>torch</code>.
</p>

<pre><code class="language-python">
%pip install biostarling
%pip install lightning_lite
%pip install scanpy
%pip install anndata
%pip install numpy
%pip install pandas
%pip install scikit-learn
%pip install matplotlib
%pip install seaborn
%pip install umap-learn
%pip install starling
%pip install utils
%pip install phenograph
%pip install torch
</code></pre>

<p>Now we can import the installed libraries:</p>

<pre><code class="language-python">
import anndata as ad
import pandas as pd
import scanpy as sc
import anndata as ann
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import umap.umap_ as umap

import phenograph
import torch
from starling import starling, utility
from lightning_lite import seed_everything
from sklearn.metrics import silhouette_score, adjusted_rand_score

import pytorch_lightning as pl
</code></pre>

<hr>

<h2>Step 2: Setting the Seed</h2>

<p>
    Setting a seed ensures reproducibility. Random number generators in Python can produce different results each run unless a seed is fixed.  
    By setting the seed at the start, we ensure the same random operations yield identical results across runs.
</p>

<pre><code class="language-python">
seed_everything(10, workers=True)
</code></pre>

<hr>

<h2>Step 3: Loading the Data</h2>

<p>
    STARLING uses spatial single-cell data stored in the <code>.h5ad</code> format, which is the standard file type for <code>anndata</code> objects.  
    These files store both the cell-by-gene (or marker) expression matrix and associated metadata, making them convenient for downstream analysis.
</p>

<p>
    In this example, we will download a sample dataset from the STARLING GitHub repository.  
    If you have your own <code>.h5ad</code> file, upload it to Google Colab or mount your Google Drive and update the <code>DATA_PATH</code> variable accordingly.
</p>

<pre><code class="language-python">
# --- 0) Setup: installs & data ---
!pip -q install git+https://github.com/camlab-bioml/starling.git scanpy anndata scikit-learn matplotlib pytorch-lightning umap-learn

import warnings, sys, os, inspect
warnings.filterwarnings("ignore")

import matplotlib.pyplot as plt

# STARLING imports
from starling import utility               # <-- provides init_clustering
from starling.starling import ST           # <-- import ST from submodule
from pytorch_lightning import seed_everything

# Download sample dataset
!wget -q https://github.com/camlab-bioml/starling/raw/main/docs/source/tutorial/sample_input.h5ad

# Path to dataset
DATA_PATH = "sample_input.h5ad"  # Change this if using your own data
</code></pre>

<hr>

<h2>Step 4: (Next Steps)</h2>
<h2>Step 1: Understanding the Data & Key Methods</h2>

<p>
    <code>.h5ad</code> is the standard file format used by <code>AnnData</code> to store single-cell datasets. It typically contains:
</p>

<ul>
    <li><b>Expression matrix:</b> Each row = a single cell (or segmented object from imaging), each column = a measured feature (gene, protein, or intensity). Often stored in a sparse format to save memory; converted to dense via <code>_to_dense()</code> when algorithms like KMeans or GMM require standard array math.</li>
    <li><b>Cell metadata (<code>.obs</code>):</b> Information like spatial coordinates, cluster IDs, or cell area.</li>
    <li><b>Feature metadata (<code>.var</code>):</b> Marker names and related information.</li>
    <li><b>Dimensionality reductions (<code>.obsm</code>):</b> PCA, UMAP embeddings for clustering, visualization, and metrics.</li>
</ul>

<p>
    <b>Leiden clustering:</b> A graph-based community detection algorithm. It builds a k-nearest-neighbor graph of cells and optimizes modularity, grouping cells into communities.  
    <br><i>In contrast:</i>
</p>
<ul>
    <li><b>KMeans:</b> Assigns cells to the nearest centroid, minimizing within-cluster variance. Assumes spherical clusters.</li>
    <li><b>Gaussian Mixture Model (GMM):</b> A probabilistic version of KMeans, assuming Gaussian-shaped clusters and producing membership probabilities.</li>
</ul>

<p>
    <b>UMAP:</b> A dimensionality reduction technique that preserves local neighborhood structure, mapping high-dimensional measurements into a 2D space. In this workflow, UMAP is used to create embeddings for silhouette scoring and visual assessment of clustering quality.
</p>

<p>
    <b>Important parameters:</b>
</p>
<ul>
    <li><code>SPATIAL_X</code>, <code>SPATIAL_Y</code>: Column names in <code>.obs</code> for spatial coordinates.</li>
    <li><code>CELL_AREA</code>: Optional; cell area measurement.</li>
    <li><code>K_TARGET</code>: Target number of clusters for KMeans/GMM. Biologically important—too low merges distinct cell types, too high creates artificial subgroups.</li>
    <li><code>EXCLUSIVITY_MARKERS</code> & <code>IMPLAUSIBLE_PAIRS</code>: Biological sanity checks (e.g., CD3 vs CD20 shouldn’t co-express in the same cell).</li>
    <li><code>OUT_DIR</code>: Output directory for results.</li>
</ul>

<p>
    <b>Key functions in the script:</b>
</p>
<ul>
    <li><code>utility.init_clustering()</code>: Prepares the <code>AnnData</code> object for STARLING and naive methods.</li>
    <li><code>_to_dense()</code>: Converts sparse expression data to a dense array.</li>
    <li><code>sc.pp.neighbors()</code>: Builds a cell-cell similarity graph.</li>
    <li><code>sc.tl.umap()</code>: Runs UMAP for visualization.</li>
</ul>

<h2>Step 2: Example Benchmark Script</h2>

<pre><code class="language-python">
# =========================
# Colab Benchmark: STARLING vs Naive Clustering
# =========================

# --- 0) Setup: installs & data ---
!pip -q install git+https://github.com/camlab-bioml/starling.git scanpy anndata scikit-learn matplotlib pytorch-lightning umap-learn

# Sample dataset (replace with your own .h5ad in /content or Drive)
!wget -q https://github.com/camlab-bioml/starling/raw/main/docs/source/tutorial/sample_input.h5ad

# --- 1) Config (edit these as needed) ---
DATA_PATH = "sample_input.h5ad"    # your file path

SPATIAL_X = "X"
SPATIAL_Y = "Y"
CELL_AREA = "area"                 # optional
TRUE_LABELS = None                 # ground-truth label key if available

K_TARGET = 10                      # K for KMeans/GMM

EXCLUSIVITY_MARKERS = ["CD3", "CD20"]
IMPLAUSIBLE_PAIRS   = [("CD3", "CD20"),
                       ("Cytokeratin", "Vimentin")]

OUT_DIR = "outputs"
os.makedirs(OUT_DIR, exist_ok=True)

# --- 2) Load data ---
adata = utility.init_clustering("KM", ad.read_h5ad(DATA_PATH), k=K_TARGET)

def _to_dense(X):
    return np.asarray(X.todense()) if hasattr(X, "todense") else np.asarray(X)

X_dense = _to_dense(adata.X)

# --- 3) Neighbors + UMAP ---
sc.pp.neighbors(adata, use_rep=None, n_neighbors=15)
sc.tl.umap(adata)

# Leiden
sc.tl.leiden(adata, resolution=1.0)
adata.obs["leiden"] = adata.obs["leiden"].astype(str)

# KMeans
X_scaled = StandardScaler().fit_transform(X_dense)
adata.obs["kmeans"] = KMeans(n_clusters=K_TARGET, n_init="auto", random_state=0).fit_predict(X_scaled).astype(str)

# GMM
adata.obs["gmm"] = GaussianMixture(n_components=K_TARGET, covariance_type="full", random_state=0).fit_predict(X_scaled).astype(str)
</code></pre>

    <h2>Step 3: Running STARLING & Evaluating Results</h2>

<p>
    <b><code>use_cell_size</code>:</b> Checks if the dataset contains cell area measurements; includes them in the model if available.
</p>

<p>
    <b><code>ST(...)</code>:</b> Creates a STARLING model with key parameters:
</p>
<ul>
    <li><code>dist_option='T'</code> — Distance metric for comparing cells.</li>
    <li><code>singlet_prop</code> — Weight for “pure” (non-overlapping) cells.</li>
    <li><code>model_cell_size</code> — Whether to use cell area in clustering.</li>
    <li><code>model_zplane_overlap</code> — Whether to model z-axis cell overlaps.</li>
    <li><code>model_regularizer</code> — Penalty to prevent overfitting.</li>
    <li><code>learning_rate</code> — Training step size.</li>
</ul>

<p>
    <b><code>st.train_and_fit()</code>:</b> Trains the STARLING model on the input data.
</p>

<p>
    STARLING’s predicted cluster IDs may be stored in different places depending on version/configuration, so the code:
</p>
<ol>
    <li>Checks for new columns in <code>.obs</code> with names like “starling”, “cluster”, “assign”, “pred”.</li>
    <li>If none found, searches all <code>.obs</code> columns for similar names.</li>
    <li>Tests if the column looks like valid labels (categorical, 2+ unique values, fewer than number of cells).</li>
    <li>Falls back to searching <code>.uns</code>, <code>.obsm</code>, or common <code>ST</code> object attributes.</li>
</ol>

<h3>Metric helpers</h3>
<ul>
    <li><b><code>silhouette_on_umap(adata, labels_key)</code></b> — Computes silhouette score in 2D UMAP space:
        <br>Formula: <code>s(i) = (b(i) - a(i)) / max(a(i), b(i))</code>  
        where <code>a(i)</code> is average intra-cluster distance, <code>b(i)</code> is smallest average inter-cluster distance.  
        Range: [-1, 1], higher = better.  
        Caveat: Measures separation in UMAP space, which is nonlinear and can distort distances.
    </li>
    <li><b><code>compute_ari(adata, labels_key, truth_key)</code></b> — Adjusted Rand Index between predicted and true labels.  
        Range: [-1, 1]; 0 ≈ random, 1 = perfect match; NaN if truth missing.
    </li>
    <li><b><code>marker_exclusivity(...)</code></b> — Measures if a marker is concentrated in a specific cluster.  
        Score ≈ 1 means a cleanly owned marker.
    </li>
    <li><b><code>implausible_coexp_rate(...)</code></b> — Fraction of cells co-expressing two biologically implausible markers above the 90th percentile. Lower = better.</li>
</ul>

<h3>Aggregate evaluation</h3>
<p>
    <code>evaluate_method(...)</code> returns:
</p>
<ul>
    <li>Silhouette@UMAP</li>
    <li>ARI (if ground truth)</li>
    <li>One exclusivity score per marker in <code>EXCLUSIVITY_MARKERS</code></li>
    <li>One implausible co-expression rate per pair in <code>IMPLAUSIBLE_PAIRS</code></li>
</ul>
<p>
    The script evaluates only methods present in <code>adata.obs</code> and saves results to <code>outputs/benchmark_metrics.csv</code>.
</p>

<h3>Visualization</h3>
<p>
    <code>sc.pl.umap(...)</code> colors cells by cluster label on the existing UMAP embedding and saves to <code>umap_{method}.png</code>.
</p>

<pre><code class="language-python">
# --- Construct STARLING model ---
use_cell_size = ("area" in adata.obs.columns)
st = ST(
    adata=adata,
    dist_option='T',
    singlet_prop=0.6,
    model_cell_size=use_cell_size,
    cell_size_col_name='area',
    model_zplane_overlap=True,
    model_regularizer=1.0,
    learning_rate=1e-3
)

st.train_and_fit()

# Use adata inside ST if available
adata = st.adata if hasattr(st, "adata") and st.adata is not None else adata

# --- Locate STARLING labels ---
label_key = None
n_cells = adata.n_obs
pre_cols = set(adata.obs.columns)
post_cols = set(adata.obs.columns)
new_cols = list(post_cols - pre_cols)
priors = ["starling", "st", "cluster", "label", "assign", "pred"]

# Check new obs columns
candidates = [c for c in new_cols if any(p in c.lower() for p in priors)]

# Fallback: scan all obs cols
if not candidates:
    candidates = [c for c in adata.obs.columns if any(p in c.lower() for p in priors)]

def looks_labelish(s):
    s = pd.Categorical(s)
    k = s.categories.size
    return (k >= 2) and (k <= int(len(s) * 0.9))

for c in candidates:
    if looks_labelish(adata.obs[c]):
        label_key = c
        break

# Check uns/obsm
if label_key is None:
    for store in (getattr(adata, "uns", {}), getattr(adata, "obsm", {})):
        for k, v in store.items():
            try:
                arr = np.asarray(v)
                if arr.ndim == 1 and arr.shape[0] == n_cells:
                    adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                    label_key = "starling_labels"
                    break
            except Exception:
                pass
        if label_key is not None:
            break

# Check ST attributes
if label_key is None:
    for attr in ["pred", "labels_", "y_pred", "assignments", "clusters", "y", "labels"]:
        if hasattr(st, attr):
            try:
                arr = np.asarray(getattr(st, attr))
                if arr.ndim == 1 and arr.shape[0] == n_cells:
                    adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                    label_key = "starling_labels"
                    break
            except Exception:
                pass

# Scan ST.__dict__ for 1D arrays
if label_key is None:
    for k, v in st.__dict__.items():
        try:
            arr = np.asarray(v)
            if arr.ndim == 1 and arr.shape[0] == n_cells:
                adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                label_key = "starling_labels"
                print(f"[info] Using st.{k} as labels")
                break
        except Exception:
            pass

# Debug if not found
if label_key is None:
    print("DEBUG: could not auto-find labels.")
    raise RuntimeError("STARLING labels not found; see debug output.")

# Normalize key
if label_key != "starling_labels":
    adata.obs["starling_labels"] = adata.obs[label_key].astype(str).values
print(f"Using STARLING labels from obs['{label_key}'] -> obs['starling_labels']")
</code></pre>


</div>
<footer>
    &copy; 2025 STARLING Education Page – Designed for students learning spatial biology.
</footer>
</body>
</html>
