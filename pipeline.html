<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STARLING Example Pipeline</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #f8fafc;
            color: #1e293b;
        }
        /* Sticky top nav bar */
        nav {
            background-color: #1a73e8;
            padding: 10px 20px;
            position: sticky;
            top: 0;
            z-index: 1000;
            text-align: left;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 20px;
            font-weight: bold;
        }
        nav a:hover {
            text-decoration: underline;
        }
        header {
            background-color: #0f172a;
            color: white;
            padding: 1rem 2rem;
            text-align: center;
        }
        main {
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        section {
            background: white;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
        }
        h2 {
            color: #0f172a;
        }
        footer {
            text-align: center;
            background-color: #0f172a;
            color: #94a3b8;
            padding: 1rem;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<!-- Sticky Navigation Bar -->
<nav>
    <a href="https://osipyaan.github.io/expstar/">Home</a>
    <a href="https://osipyaan.github.io/expstar/pipeline" target="_blank">Example Pipeline</a>
    <a href="INSERT_CODE_LINK_HERE" target="_blank">Code</a>
    <a href="INSERT_CAMPBELL_LAB_LINK_HERE" target="_blank">Campbell Lab</a>
</nav>

<!-- Page Header -->
<header>
    <h1>STARLING: Making Spatial Biology Clear</h1>
    <img src="logo.png" alt="Logo" width="100" height="100" />
    <p>Understanding complex cell data — without the headaches.</p>
</header>
<body>

<div class="content">

<h1>STARLING Tutorial</h1>

<p>
    In this tutorial, we will use <strong>Google Colab</strong> to run STARLING — a probabilistic machine learning model for clustering spatial proteomics data.
    Google Colab is chosen so that you can run the example without worrying about local environment setup.
</p>

<p>
    Code for this tutorial can be accessed here: <a href="INSERT_CODE_LINK_HERE">[Code Link]</a><br>
    Credit to <strong>Campbell Lab</strong> for developing the STARLING library and providing the sample code:
    <a href="INSERT_CAMPBELL_LAB_LINK_HERE">[Campbell Lab Link]</a>
</p>

<hr>

<h2><a href="https://osipyaan.github.io/expstar/pipeline" target="_blank">Example Pipeline</a></h2>
<p>
    Click the heading above to see a full example pipeline for running STARLING, from installation to visualization.
    This external page provides a step-by-step breakdown of the data preprocessing, clustering, and plotting process.
</p>

<hr>

<h2>Step 1: Imports</h2>

<p>
    First, we will install the required Python packages. These include core analysis libraries like
    <code>scanpy</code>, <code>anndata</code>, and <code>numpy</code>, as well as visualization tools like
    <code>matplotlib</code> and <code>seaborn</code>. We also install STARLING itself and supporting tools like
    <code>phenograph</code> and <code>torch</code>.
</p>

<pre><code class="language-python">
%pip install biostarling
%pip install lightning_lite
%pip install scanpy
%pip install anndata
%pip install numpy
%pip install pandas
%pip install scikit-learn
%pip install matplotlib
%pip install seaborn
%pip install umap-learn
%pip install starling
%pip install utils
%pip install phenograph
%pip install torch
</code></pre>

<p>Now we can import the installed libraries:</p>

<pre><code class="language-python">
import anndata as ad
import pandas as pd
import scanpy as sc
import anndata as ann
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import umap.umap_ as umap

import phenograph
import torch
from starling import starling, utility
from lightning_lite import seed_everything
from sklearn.metrics import silhouette_score, adjusted_rand_score

import pytorch_lightning as pl
</code></pre>

<hr>

<h2>Step 2: Setting the Seed</h2>

<p>
    Setting a seed ensures reproducibility. Random number generators in Python can produce different results each run unless a seed is fixed.  
    By setting the seed at the start, we ensure the same random operations yield identical results across runs.
</p>

<pre><code class="language-python">
seed_everything(10, workers=True)
</code></pre>

<hr>

<h2>Step 3: Loading the Data</h2>

<p>
    STARLING uses spatial single-cell data stored in the <code>.h5ad</code> format, which is the standard file type for <code>anndata</code> objects.  
    These files store both the cell-by-gene (or marker) expression matrix and associated metadata, making them convenient for downstream analysis.
</p>

<p>
    In this example, we will download a sample dataset from the STARLING GitHub repository.  
    If you have your own <code>.h5ad</code> file, upload it to Google Colab or mount your Google Drive and update the <code>DATA_PATH</code> variable accordingly.
</p>

<pre><code class="language-python">
# --- 0) Setup: installs & data ---
!pip -q install git+https://github.com/camlab-bioml/starling.git scanpy anndata scikit-learn matplotlib pytorch-lightning umap-learn

import warnings, sys, os, inspect
warnings.filterwarnings("ignore")

import matplotlib.pyplot as plt

# STARLING imports
from starling import utility               # <-- provides init_clustering
from starling.starling import ST           # <-- import ST from submodule
from pytorch_lightning import seed_everything

# Download sample dataset
!wget -q https://github.com/camlab-bioml/starling/raw/main/docs/source/tutorial/sample_input.h5ad

# Path to dataset
DATA_PATH = "sample_input.h5ad"  # Change this if using your own data
</code></pre>

<hr>

<h2>Step 4: (Next Steps)</h2>
<h2>Step 1: Understanding the Data & Key Methods</h2>

<p>
    <code>.h5ad</code> is the standard file format used by <code>AnnData</code> to store single-cell datasets. It typically contains:
</p>

<ul>
    <li><b>Expression matrix:</b> Each row = a single cell (or segmented object from imaging), each column = a measured feature (gene, protein, or intensity). Often stored in a sparse format to save memory; converted to dense via <code>_to_dense()</code> when algorithms like KMeans or GMM require standard array math.</li>
    <li><b>Cell metadata (<code>.obs</code>):</b> Information like spatial coordinates, cluster IDs, or cell area.</li>
    <li><b>Feature metadata (<code>.var</code>):</b> Marker names and related information.</li>
    <li><b>Dimensionality reductions (<code>.obsm</code>):</b> PCA, UMAP embeddings for clustering, visualization, and metrics.</li>
</ul>

<p>
    <b>Leiden clustering:</b> A graph-based community detection algorithm. It builds a k-nearest-neighbor graph of cells and optimizes modularity, grouping cells into communities.  
    <br><i>In contrast:</i>
</p>
<ul>
    <li><b>KMeans:</b> Assigns cells to the nearest centroid, minimizing within-cluster variance. Assumes spherical clusters.</li>
    <li><b>Gaussian Mixture Model (GMM):</b> A probabilistic version of KMeans, assuming Gaussian-shaped clusters and producing membership probabilities.</li>
</ul>

<p>
    <b>UMAP:</b> A dimensionality reduction technique that preserves local neighborhood structure, mapping high-dimensional measurements into a 2D space. In this workflow, UMAP is used to create embeddings for silhouette scoring and visual assessment of clustering quality.
</p>

<p>
    <b>Important parameters:</b>
</p>
<ul>
    <li><code>SPATIAL_X</code>, <code>SPATIAL_Y</code>: Column names in <code>.obs</code> for spatial coordinates.</li>
    <li><code>CELL_AREA</code>: Optional; cell area measurement.</li>
    <li><code>K_TARGET</code>: Target number of clusters for KMeans/GMM. Biologically important—too low merges distinct cell types, too high creates artificial subgroups.</li>
    <li><code>EXCLUSIVITY_MARKERS</code> & <code>IMPLAUSIBLE_PAIRS</code>: Biological sanity checks (e.g., CD3 vs CD20 shouldn’t co-express in the same cell).</li>
    <li><code>OUT_DIR</code>: Output directory for results.</li>
</ul>

<p>
    <b>Key functions in the script:</b>
</p>
<ul>
    <li><code>utility.init_clustering()</code>: Prepares the <code>AnnData</code> object for STARLING and naive methods.</li>
    <li><code>_to_dense()</code>: Converts sparse expression data to a dense array.</li>
    <li><code>sc.pp.neighbors()</code>: Builds a cell-cell similarity graph.</li>
    <li><code>sc.tl.umap()</code>: Runs UMAP for visualization.</li>
</ul>

<h2>Step 2: Example Benchmark Script</h2>

<pre><code class="language-python">
# =========================
# Colab Benchmark: STARLING vs Naive Clustering
# =========================

# --- 0) Setup: installs & data ---
!pip -q install git+https://github.com/camlab-bioml/starling.git scanpy anndata scikit-learn matplotlib pytorch-lightning umap-learn

# Sample dataset (replace with your own .h5ad in /content or Drive)
!wget -q https://github.com/camlab-bioml/starling/raw/main/docs/source/tutorial/sample_input.h5ad

# --- 1) Config (edit these as needed) ---
DATA_PATH = "sample_input.h5ad"    # your file path

SPATIAL_X = "X"
SPATIAL_Y = "Y"
CELL_AREA = "area"                 # optional
TRUE_LABELS = None                 # ground-truth label key if available

K_TARGET = 10                      # K for KMeans/GMM

EXCLUSIVITY_MARKERS = ["CD3", "CD20"]
IMPLAUSIBLE_PAIRS   = [("CD3", "CD20"),
                       ("Cytokeratin", "Vimentin")]

OUT_DIR = "outputs"
os.makedirs(OUT_DIR, exist_ok=True)

# --- 2) Load data ---
adata = utility.init_clustering("KM", ad.read_h5ad(DATA_PATH), k=K_TARGET)

def _to_dense(X):
    return np.asarray(X.todense()) if hasattr(X, "todense") else np.asarray(X)

X_dense = _to_dense(adata.X)

# --- 3) Neighbors + UMAP ---
sc.pp.neighbors(adata, use_rep=None, n_neighbors=15)
sc.tl.umap(adata)

# Leiden
sc.tl.leiden(adata, resolution=1.0)
adata.obs["leiden"] = adata.obs["leiden"].astype(str)

# KMeans
X_scaled = StandardScaler().fit_transform(X_dense)
adata.obs["kmeans"] = KMeans(n_clusters=K_TARGET, n_init="auto", random_state=0).fit_predict(X_scaled).astype(str)

# GMM
adata.obs["gmm"] = GaussianMixture(n_components=K_TARGET, covariance_type="full", random_state=0).fit_predict(X_scaled).astype(str)
</code></pre>

    <h2>Step 3: Running STARLING & Evaluating Results</h2>

<p>
    <b><code>use_cell_size</code>:</b> Checks if the dataset contains cell area measurements; includes them in the model if available.
</p>

<p>
    <b><code>ST(...)</code>:</b> Creates a STARLING model with key parameters:
</p>
<ul>
    <li><code>dist_option='T'</code> — Distance metric for comparing cells.</li>
    <li><code>singlet_prop</code> — Weight for “pure” (non-overlapping) cells.</li>
    <li><code>model_cell_size</code> — Whether to use cell area in clustering.</li>
    <li><code>model_zplane_overlap</code> — Whether to model z-axis cell overlaps.</li>
    <li><code>model_regularizer</code> — Penalty to prevent overfitting.</li>
    <li><code>learning_rate</code> — Training step size.</li>
</ul>

<p>
    <b><code>st.train_and_fit()</code>:</b> Trains the STARLING model on the input data.
</p>

<p>
    STARLING’s predicted cluster IDs may be stored in different places depending on version/configuration, so the code:
</p>
<ol>
    <li>Checks for new columns in <code>.obs</code> with names like “starling”, “cluster”, “assign”, “pred”.</li>
    <li>If none found, searches all <code>.obs</code> columns for similar names.</li>
    <li>Tests if the column looks like valid labels (categorical, 2+ unique values, fewer than number of cells).</li>
    <li>Falls back to searching <code>.uns</code>, <code>.obsm</code>, or common <code>ST</code> object attributes.</li>
</ol>

<h3>Metric helpers</h3>
<ul>
    <li><b><code>silhouette_on_umap(adata, labels_key)</code></b> — Computes silhouette score in 2D UMAP space:
        <br>Formula: <code>s(i) = (b(i) - a(i)) / max(a(i), b(i))</code>  
        where <code>a(i)</code> is average intra-cluster distance, <code>b(i)</code> is smallest average inter-cluster distance.  
        Range: [-1, 1], higher = better.  
        Caveat: Measures separation in UMAP space, which is nonlinear and can distort distances.
    </li>
    <li><b><code>compute_ari(adata, labels_key, truth_key)</code></b> — Adjusted Rand Index between predicted and true labels.  
        Range: [-1, 1]; 0 ≈ random, 1 = perfect match; NaN if truth missing.
    </li>
    <li><b><code>marker_exclusivity(...)</code></b> — Measures if a marker is concentrated in a specific cluster.  
        Score ≈ 1 means a cleanly owned marker.
    </li>
    <li><b><code>implausible_coexp_rate(...)</code></b> — Fraction of cells co-expressing two biologically implausible markers above the 90th percentile. Lower = better.</li>
</ul>

<h3>Aggregate evaluation</h3>
<p>
    <code>evaluate_method(...)</code> returns:
</p>
<ul>
    <li>Silhouette@UMAP</li>
    <li>ARI (if ground truth)</li>
    <li>One exclusivity score per marker in <code>EXCLUSIVITY_MARKERS</code></li>
    <li>One implausible co-expression rate per pair in <code>IMPLAUSIBLE_PAIRS</code></li>
</ul>
<p>
    The script evaluates only methods present in <code>adata.obs</code> and saves results to <code>outputs/benchmark_metrics.csv</code>.
</p>

<h3>Visualization</h3>
<p>
    <code>sc.pl.umap(...)</code> colors cells by cluster label on the existing UMAP embedding and saves to <code>umap_{method}.png</code>.
</p>

<pre><code class="language-python">
# --- Construct STARLING model ---
use_cell_size = ("area" in adata.obs.columns)
st = ST(
    adata=adata,
    dist_option='T',
    singlet_prop=0.6,
    model_cell_size=use_cell_size,
    cell_size_col_name='area',
    model_zplane_overlap=True,
    model_regularizer=1.0,
    learning_rate=1e-3
)

st.train_and_fit()

# Use adata inside ST if available
adata = st.adata if hasattr(st, "adata") and st.adata is not None else adata

# --- Locate STARLING labels ---
label_key = None
n_cells = adata.n_obs
pre_cols = set(adata.obs.columns)
post_cols = set(adata.obs.columns)
new_cols = list(post_cols - pre_cols)
priors = ["starling", "st", "cluster", "label", "assign", "pred"]

# Check new obs columns
candidates = [c for c in new_cols if any(p in c.lower() for p in priors)]

# Fallback: scan all obs cols
if not candidates:
    candidates = [c for c in adata.obs.columns if any(p in c.lower() for p in priors)]

def looks_labelish(s):
    s = pd.Categorical(s)
    k = s.categories.size
    return (k >= 2) and (k <= int(len(s) * 0.9))

for c in candidates:
    if looks_labelish(adata.obs[c]):
        label_key = c
        break

# Check uns/obsm
if label_key is None:
    for store in (getattr(adata, "uns", {}), getattr(adata, "obsm", {})):
        for k, v in store.items():
            try:
                arr = np.asarray(v)
                if arr.ndim == 1 and arr.shape[0] == n_cells:
                    adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                    label_key = "starling_labels"
                    break
            except Exception:
                pass
        if label_key is not None:
            break

# Check ST attributes
if label_key is None:
    for attr in ["pred", "labels_", "y_pred", "assignments", "clusters", "y", "labels"]:
        if hasattr(st, attr):
            try:
                arr = np.asarray(getattr(st, attr))
                if arr.ndim == 1 and arr.shape[0] == n_cells:
                    adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                    label_key = "starling_labels"
                    break
            except Exception:
                pass

# Scan ST.__dict__ for 1D arrays
if label_key is None:
    for k, v in st.__dict__.items():
        try:
            arr = np.asarray(v)
            if arr.ndim == 1 and arr.shape[0] == n_cells:
                adata.obs["starling_labels"] = pd.Series(arr).astype(str).values
                label_key = "starling_labels"
                print(f"[info] Using st.{k} as labels")
                break
        except Exception:
            pass

# Debug if not found
if label_key is None:
    print("DEBUG: could not auto-find labels.")
    raise RuntimeError("STARLING labels not found; see debug output.")

# Normalize key
if label_key != "starling_labels":
    adata.obs["starling_labels"] = adata.obs[label_key].astype(str).values
print(f"Using STARLING labels from obs['{label_key}'] -> obs['starling_labels']")
</code></pre>
<h2>Step 4: Metrics & Visualization</h2>

<p>
    This section defines helper functions to compute clustering evaluation metrics, applies them to each method, saves the results, and generates UMAP and spatial plots.
</p>

<h3>Metric functions</h3>
<ul>
    <li>
        <b><code>silhouette_on_umap(adata, labels_key)</code></b> — Computes the silhouette score using the 2D UMAP embedding (<code>adata.obsm["X_umap"]</code>) and cluster labels.  
        <ul>
            <li>Formula: <code>s(i) = (b(i) - a(i)) / max(a(i), b(i))</code>, where <code>a(i)</code> = mean intra-cluster distance, <code>b(i)</code> = mean nearest-cluster distance.</li>
            <li>Range: [-1, 1], higher = better.</li>
            <li>NaN if fewer than two unique labels or no UMAP embedding.</li>
        </ul>
    </li>
    <li>
        <b><code>compute_ari(adata, labels_key, truth_key)</code></b> — Computes Adjusted Rand Index (ARI) between predicted labels and ground truth.  
        <ul>
            <li>Range: [-1, 1]; 0 ≈ random, 1 = perfect match.</li>
            <li>NaN if <code>truth_key</code> missing.</li>
        </ul>
    </li>
    <li>
        <b><code>marker_exclusivity(...)</code></b> — Measures if a marker is concentrated in one cluster by comparing mean expression inside vs. outside the cluster.  
        <ul>
            <li>Score ≈ 1 means a cleanly “owned” marker.</li>
            <li>NaN if marker missing.</li>
        </ul>
    </li>
    <li>
        <b><code>implausible_coexp_rate(...)</code></b> — Measures fraction of cells with high co-expression of two biologically implausible markers (above <code>q</code>-quantile).  
        <ul>
            <li>Lower = better.</li>
            <li>NaN if either marker missing.</li>
        </ul>
    </li>
</ul>

<h3>Aggregate evaluation</h3>
<p>
    <code>evaluate_method(...)</code> returns a dictionary of:
</p>
<ul>
    <li>Silhouette@UMAP</li>
    <li>ARI (if ground truth)</li>
    <li>One exclusivity score per marker in <code>EXCLUSIVITY_MARKERS</code></li>
    <li>One implausible co-expression rate per pair in <code>IMPLAUSIBLE_PAIRS</code></li>
</ul>
<p>
    These are run for each clustering method present in <code>adata.obs</code>, compiled into a DataFrame, saved as <code>benchmark_metrics.csv</code>, and rounded to 4 decimals.
</p>

<h3>Visualization</h3>
<ul>
    <li><b>UMAP plots:</b> Colors cells by cluster labels and saves as <code>umap_{method}.png</code>.</li>
    <li><b>Spatial plots:</b> If spatial coordinates (<code>SPATIAL_X</code>, <code>SPATIAL_Y</code>) are present, colors cells by cluster labels in spatial context. If <code>sc.pl.spatial</code> is unavailable, falls back to a simple scatter plot.</li>
</ul>

<pre><code class="language-python">
def silhouette_on_umap(adata, labels_key):
    if "X_umap" not in adata.obsm or adata.obsm["X_umap"] is None:
        return np.nan
    emb = np.asarray(adata.obsm["X_umap"])
    labs = adata.obs[labels_key].values
    if len(np.unique(labs)) < 2:
        return np.nan
    return float(silhouette_score(emb, labs))

def compute_ari(adata, labels_key, truth_key):
    if truth_key is None or truth_key not in adata.obs.columns:
        return np.nan
    return float(adjusted_rand_score(adata.obs[truth_key].values,
                                     adata.obs[labels_key].values))

def marker_exclusivity(adata, labels_key, marker_name):
    if marker_name not in adata.var_names:
        return np.nan
    v = _to_dense(adata[:, marker_name].X).reshape(-1)
    labs = adata.obs[labels_key].values
    best = -np.inf
    for lab in pd.unique(labs):
        m_in  = v[labs == lab].mean() if (labs == lab).sum() else 0.0
        m_out = v[labs != lab].mean() if (labs != lab).sum() else 0.0
        denom = m_in + m_out
        score = m_in/denom if denom > 0 else np.nan
        if score > best:
            best = score
    return float(best)

def implausible_coexp_rate(adata, m1, m2, q=0.9):
    if (m1 not in adata.var_names) or (m2 not in adata.var_names):
        return np.nan
    v1 = _to_dense(adata[:, m1].X).reshape(-1)
    v2 = _to_dense(adata[:, m2].X).reshape(-1)
    t1, t2 = np.quantile(v1, q), np.quantile(v2, q)
    return float(((v1 >= t1) & (v2 >= t2)).mean())

def evaluate_method(adata, labels_key):
    res = {
        "silhouette@UMAP": silhouette_on_umap(adata, labels_key),
        "ARI": compute_ari(adata, labels_key, TRUE_LABELS)
    }
    for m in EXCLUSIVITY_MARKERS:
        res[f"exclusivity[{m}]"] = marker_exclusivity(adata, labels_key, m)
    for (m1, m2) in IMPLAUSIBLE_PAIRS:
        res[f"implausible[{m1}&{m2}]"] = implausible_coexp_rate(adata, m1, m2)
    return res

methods = ["leiden", "kmeans", "gmm", starling_key]
rows = []
for key in methods:
    if key in adata.obs.columns:
        row = evaluate_method(adata, key)
        row["method"] = key
        rows.append(row)

df = pd.DataFrame(rows).set_index("method").sort_index()
display(df.round(4))
df.to_csv(f"{OUT_DIR}/benchmark_metrics.csv", index=True)
print(f"Saved metrics to {OUT_DIR}/benchmark_metrics.csv")

# --- Plots: UMAP & Spatial ---
for key in methods:
    if key in adata.obs.columns:
        sc.pl.umap(adata, color=key, title=f"UMAP — {key}", show=False)
        plt.savefig(f"{OUT_DIR}/umap_{key}.png", dpi=200, bbox_inches="tight")
        plt.close()

has_spatial = (SPATIAL_X in adata.obs.columns) and (SPATIAL_Y in adata.obs.columns)
if has_spatial:
    for key in methods:
        if key in adata.obs.columns:
            try:
                sc.pl.spatial(
                    adata, color=key, title=f"Spatial — {key}",
                    x=SPATIAL_X, y=SPATIAL_Y, spot_size=20, show=False
                )
                plt.savefig(f"{OUT_DIR}/spatial_{key}.png", dpi=200, bbox_inches="tight")
                plt.close()
            except Exception:
                plt.figure()
                ax = plt.gca()
                ax.scatter(
                    adata.obs[SPATIAL_X], adata.obs[SPATIAL_Y],
                    c=pd.Categorical(adata.obs[key]).codes, s=5
                )
                ax.set_title(f"Spatial — {key}")
                ax.set_aspect("equal")
                plt.savefig(f"{OUT_DIR}/spatial_{key}.png", dpi=200, bbox_inches="tight")
                plt.close()

print("Wrote figures to:", OUT_DIR)
</code></pre>
<h2>Step 5: Comparing Unweighted vs Weighted UMAP</h2>

<p>
    This section compares UMAP embeddings computed from <b>unweighted</b> vs <b>segmentation-error–weighted</b> neighbor graphs.  
    The goal is to check whether accounting for segmentation error changes cluster separation in the low-dimensional layout.
</p>

<h3>Workflow</h3>
<ol>
    <li>
        <b>Ensure unweighted UMAP is available:</b>  
        If <code>X_umap</code> is missing from <code>adata.obsm</code>, build a k-nearest-neighbor graph using unweighted principal components (<code>X_pca</code>), then run UMAP. Save the result as <code>X_umap_unweighted</code>.
    </li>
    <li>
        <b>Compute weighted UMAP:</b>  
        Build neighbors using weighted principal components (<code>X_pca_weighted</code>).  
        Run UMAP, preferring to save to <code>umap_weighted</code> via the <code>key_added</code> argument if available.  
        Fallback: if Scanpy is too old to support <code>key_added</code>, UMAP may overwrite <code>X_umap</code>.
    </li>
    <li>
        <b>Normalize keys:</b>  
        Ensure <code>X_umap_weighted</code> exists. If the key was ignored, manually copy the overwritten <code>X_umap</code> to <code>X_umap_weighted</code> and restore <code>X_umap</code> from <code>X_umap_unweighted</code>.
    </li>
    <li>
        <b>Recompute silhouette scores:</b>  
        Use <code>safe_sil(...)</code> to compute silhouette@UMAP for unweighted and weighted embeddings, handling missing or single-cluster cases.
    </li>
    <li>
        <b>Side-by-side plot:</b>  
        Visualize unweighted vs weighted UMAP embeddings in the same figure, coloring points by cluster labels.
    </li>
</ol>

<pre><code class="language-python">
# 1) Ensure we have an unweighted UMAP saved
if "X_umap" not in adata.obsm:
    sc.pp.neighbors(adata, use_rep="X_pca", n_neighbors=15, key_added="neighbors_unweighted")
    sc.tl.umap(adata, min_dist=0.3)
adata.obsm["X_umap_unweighted"] = adata.obsm["X_umap"].copy()

# 2) Compute weighted UMAP using weighted graph
sc.pp.neighbors(adata, use_rep="X_pca_weighted", n_neighbors=15, key_added="neighbors_weighted")
try:
    sc.tl.umap(adata, min_dist=0.3, key_added="umap_weighted")  # preferred
except TypeError:
    sc.tl.umap(adata, min_dist=0.3)  # older Scanpy fallback

# 3) Normalize keys
if "X_umap_weighted" not in adata.obsm:
    adata.obsm["X_umap_weighted"] = adata.obsm["X_umap"].copy()
    adata.obsm["X_umap"] = adata.obsm["X_umap_unweighted"].copy()

# 4) Recompute silhouettes
from sklearn.metrics import silhouette_score

label_key = "starling_labels" if "starling_labels" in adata.obs else \
            ("leiden" if "leiden" in adata.obs else list(adata.obs.columns)[0])

def safe_sil(emb, labels):
    if emb is None or len(np.unique(labels)) < 2: return np.nan
    return float(silhouette_score(emb, labels))

sil_base = safe_sil(adata.obsm.get("X_umap_unweighted"), adata.obs[label_key].values)
sil_w    = safe_sil(adata.obsm.get("X_umap_weighted"),   adata.obs[label_key].values)
print(f"Silhouette@UMAP (unweighted → weighted) [{label_key}]: {sil_base:.4f} → {sil_w:.4f}")

# Side-by-side plotting
def plot_side_by_side(adata, labels_key, out_png):
    import matplotlib.pyplot as plt
    labs = pd.Categorical(adata.obs[labels_key].astype(str))
    palette = plt.cm.tab20(np.linspace(0,1,max(20, labs.categories.size)))
    cmap = {lab: palette[i % len(palette)] for i, lab in enumerate(labs.categories)}
    colors = np.array([cmap[v] for v in labs])

    U0 = adata.obsm["X_umap_unweighted"]
    U1 = adata.obsm["X_umap_weighted"]
    fig, axes = plt.subplots(1, 2, figsize=(9,4), dpi=160)
    for ax, U, title in zip(axes, [U0, U1], ["Unweighted UMAP", "Seg.-Error–Aware UMAP"]):
        ax.scatter(U[:,0], U[:,1], s=6, c=colors, linewidth=0)
        ax.set_title(title); ax.axis("off"); ax.set_aspect("equal")
    plt.tight_layout()
    plt.savefig(f"{OUT_DIR}/{out_png}", dpi=300, bbox_inches="tight")
    plt.show()

plot_side_by_side(adata, label_key, "umap_unweighted_vs_weighted.png")
</code></pre>

    <h2>Step 6: UMAP Morphing Animations</h2>

<p>
    This section creates smooth animations morphing between two different UMAP layouts (or color labelings),  
    allowing you to visually compare how cluster assignments change between methods (e.g., <code>KMeans</code> → <code>STARLING</code>).
</p>

<h3>Workflow</h3>
<ol>
    <li>
        <b>Output directory:</b>  
        Ensure a <code>videos</code> folder exists for saving animations.
    </li>
    <li>
        <b>make_umap_morph(...)</b> function:
        <ul>
            <li><b>Inputs:</b> starting method (<code>method_from</code>), ending method (<code>method_to</code>), base filename (<code>fname_base</code>), animation duration (<code>seconds</code>), and frames per second (<code>fps</code>).</li>
            <li>Extracts colors for the start and end layouts using <code>labels_to_colors()</code>.</li>
            <li>Initializes a scatter plot with starting colors and stores coordinates (<code>x</code>, <code>y</code>).</li>
            <li>Uses an <b>ease in-out</b> function to smoothly transition colors over time.</li>
            <li>Updates colors frame-by-frame via <code>FuncAnimation</code> from Matplotlib.</li>
            <li>Saves animations as both GIF (<code>PillowWriter</code>) and MP4 (<code>FFMpegWriter</code> if available).</li>
        </ul>
    </li>
    <li>
        <b>Creating morphs:</b>  
        Runs <code>make_umap_morph</code> for:
        <ul>
            <li><code>KMeans</code> → <code>STARLING</code></li>
            <li><code>GMM</code> → <code>STARLING</code></li>
        </ul>
        Only if both methods are present in <code>all_methods</code>.
    </li>
</ol>

<pre><code class="language-python">
import os
from matplotlib.animation import FuncAnimation, PillowWriter, FFMpegWriter

os.makedirs("videos", exist_ok=True)

def make_umap_morph(method_from, method_to, fname_base, seconds=4, fps=20):
    # Colors for start/end
    c0 = labels_to_colors(adata.obs[method_from].values[order])
    c1 = labels_to_colors(adata.obs[method_to].values[order])

    fig, ax = plt.subplots(figsize=(5,4), dpi=150)
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_title(f"UMAP: {method_from} → {method_to}")
    sc = ax.scatter(x, y, s=6, c=c0)
    ax.set_aspect("equal")

    frames = seconds * fps
    def ease(t):  # smooth in-out
        return 0.5 - 0.5*np.cos(np.pi*t)

    def update(i):
        t = ease(i / (frames-1))
        # Cross-fade colors in RGB space
        sc.set_color((1-t)*c0 + t*c1)
        ax.set_title(f"UMAP: {method_from} → {method_to}  (t={t:.2f})")
        return (sc,)

    anim = FuncAnimation(fig, update, frames=frames, interval=1000/fps, blit=True)
    # MP4 (if ffmpeg available) + GIF
    try:
        anim.save(f"videos/{fname_base}.mp4", writer=FFMpegWriter(fps=fps))
    except Exception:
        pass
    anim.save(f"videos/{fname_base}.gif", writer=PillowWriter(fps=fps))
    plt.close(fig)
    print(f"Wrote videos/{fname_base}.gif (and .mp4 if ffmpeg present)")

# Create morphs
if "kmeans" in all_methods and "starling_labels" in all_methods:
    make_umap_morph("kmeans", "starling_labels", "umap_kmeans_to_starling", seconds=4, fps=20)
if "gmm" in all_methods and "starling_labels" in all_methods:
    make_umap_morph("gmm", "starling_labels", "umap_gmm_to_starling", seconds=4, fps=20)
</code></pre>


</div>
<footer>
    &copy; 2025 STARLING Education Page – Designed for students learning spatial biology.
</footer>
</body>
</html>
